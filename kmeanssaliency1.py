# -*- coding: utf-8 -*-
"""KmeansSaliency.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gu1jRZCCkbZCck6IuBj1OtwKVYy1D2R6
"""

import numpy as np
import cv2
import warnings
warnings.filterwarnings("ignore")
import matplotlib.pyplot as plt

def kMean_saliency(img,K):
    # reshaping the image to a 2D array of pixels and 3 color (R,G,B) values
    pixel_val = img.reshape((-1, 3))
    # converting to float
    pixel_val = np.float32(pixel_val)
    # stopping criteria of k-means algorithm
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.85)
    # implementing k-means algorithm..
    _, label, center = cv2.kmeans(pixel_val,K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    center = np.uint8(center)
    label = label.flatten()
    km_img =  center[label.flatten()]
    km_img = km_img.reshape(img.shape)
    I1,I2,I3 = cv2.split(km_img)
    hist1  = cv2.calcHist([km_img],[0],None,[K],[0,256])
    hist2  = cv2.calcHist([km_img],[1],None,[K],[0,256])
    hist3  = cv2.calcHist([km_img],[2],None,[K],[0,256])
    prob1 = hist1/sum(hist1)
    prob2 = hist2/sum(hist2)
    prob3 = hist3/sum(hist3)

    [row,col,ch] = img.shape
    # to store saliency values of pixels for each channel..
    Sal1 = np.zeros((row,col))
    Sal2 = np.zeros((row,col))
    Sal3 = np.zeros((row,col))
    # computing the saliency value of each pixel in the Red channel..
    for i in range(0,row):
        for j in range(0,col):
            S_Ik = 0
            # pixel intensity at (i,j)th position..
            Ik = I1[i,j]
            # K distinct pixel colours
            for k in range(0,K):
                D = np.abs(Ik - k)
                S_Ik = S_Ik + prob1[k] * D
            Sal1[i,j] = S_Ik

    for i in range(0,row):
        for j in range(0,col):
            S_Ik = 0
            # pixel intensity at (i,j)th position..
            Ik = I2[i,j]
            # K distinct pixel colours
            for k in range(0,K):
                D = np.abs(Ik - k)
                S_Ik = S_Ik + prob2[k] * D
            Sal2[i,j] = S_Ik
          
    for i in range(0,row):
        for j in range(0,col):
            S_Ik = 0
            # pixel intensity at (i,j)th position..
            Ik = I3[i,j]
            # K distinct pixel colours
            for k in range(0,K):
                D = np.abs(Ik - K)
                S_Ik = S_Ik + prob3[k] * D
            Sal3[i,j] = S_Ik
    total_sal = (Sal1 + Sal2 + Sal3)
    return total_sal